<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Functional Programming in F#</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/vs.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Functional Programming in F#</h1>
					<h2>Daniel Wallis</h2>
				</section>




				<section>
					<h1>About me</h1>
				</section>




				<section>
					<h1>What is Functional Programming?</h1>
					A <b>programming paradigm</b> that treats computation as the evaluation of mathematical functions and <b>avoids changing-state and mutable data</b>
				</section>				




				<section>
					<h1>What are the benefits?</h1>
					<ul>
						<li class="fragment">Calling a function twice with the same arguments produces the same result</li>
						<li class="fragment">Immutability by default</li>
						<li class="fragment">No null checking</li>
						<li class="fragment">More concise syntax</li>
						<li class="fragment">Less boilerplate</li>
					</ul>
				</section>



				<section>
					<h1>Side note:</h1>
					<h3>Being concise isn't always good!</h3>
					<div class="fragment">
						What does this APL code do?!?
						<pre>
(~R∊R∘.×R)/R←1↓ιR
						</pre>
					</div>
					<div class="fragment">
						Answer: Finds all prime numbers from 1 to R
					</div>
				</section>




				<section>
					<h1>Why F#?</h1>
					<ul>
						<li class="fragment">Familiar tooling</li>
						<li class="fragment">Interoperability with C#</li>
						<li class="fragment">Use of NuGet and other DLLs</li>
						<li class="fragment">Use of existing frameworks (e.g. ASP.NET MVC)</li>
						<li class="fragment">Can be used as scripting language</li>
					</ul>
				</section>






				<section>
					<h1>Show me the code!</h1>
				</section>





				<section>
					<div style="float:left;width:50%;">
						<pre><code class="fsharp hljs" data-trim>					
printfn "Hello, World!"
						</code></pre>
						<div class="fragment">
							<pre><code class="fsharp hljs" data-trim>
type Person = {Name:string; Age:int;}

let MakePerson name =
    {Name=name; Age=0;}
							</code></pre>
							Equals and HashCode implemented by default!
						</div>				
					</div>
					<div style="float:right;width:50%;">
						<pre class="fragment smallCode"><code class="hljs" data-trim>	
public class Person
{
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    public int Age { get; }

    public string Name { get; }

    public override bool Equals(object obj)
    {
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != this.GetType()) return false;
        var other = (Person) obj;
        return Age == other.Age && string.Equals(Name, other.Name);
    }

    public override int GetHashCode()
    {
        unchecked
        {
            return (Age*397) ^ (Name?.GetHashCode() ?? 0);
        }
    }
}    
	    				</code></pre>
	    			</div>
				</section>




				<section>
					<pre><code class="fsharp hljs" data-trim>					
type Person = {Name:string; Age:int;}

let MakePerson name =
    {Name=name; Age=0;}

// Create new person by just modifying the age
let GrowOlder person = 
    {person with Age=person.Age+1}
        
printfn "Hello, World!"
let person1 = {Name="Bob";Age=52;}
let person2 = {Name="Bob";Age=52;}

// Print to console in a type-safe way
printfn "%i" (person1.GetHashCode())
printfn "%i" (person2.GetHashCode())
printfn "%b" (person1=person2)        
					</code></pre>
				</section>



				<section>
					<h2>Type inference</h2>
					<pre><code class="fsharp hljs" data-trim>	
namespace Parser

open System

module CommandLineParser = 
    let GetArgument prompt parser = 
        printf "%s" prompt
        Console.ReadLine() |> parser

    let GetInteger() = 
        GetArgument "Enter an integer: " Int32.Parse
					</code></pre>
				</section>





				<section>	
					<h2>Type inference</h2>	
					<pre><code class="hljs" data-trim>	
using System;

namespace Parser
{
    public class CommandLineParser
    {
        public static T GetArgument&ltT&gt(string prompt, Func&ltstring, T&gt parser)
        {
            Console.Write(prompt);
            return parser(Console.ReadLine());
        }

        public static int GetInteger()
        {
            return GetArgument("Enter an integer: ", int.Parse);
        }
    }
}
					</code></pre>						
				</section>







				<section>
					Tony Hoare (inventor of the null reference): 
					<blockquote>“I call it my billion-dollar mistake.
					<br/>…
					<br/>This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.”
					</blockquote>	
				</section>



				
				<section>
					<pre><code class="fsharp hljs" data-trim>								
let PrintPerson person = 
    printfn "Name:%s, Age:%i" person.Name person.Age

let NullExample() = 
    PrintPerson null

let RealExample() = 
    PrintPerson {Name="Bob"; Age=52;}
					</code></pre>
					<div class="fragment">
						No nulls! (except when using standard .NET types)
						<pre>
The type 'Person' does not have 'null' as a proper value
						</pre>
					</div>
				</section>




				<section>
					<pre><code class="fsharp hljs" data-trim>								
let PrintPerson person =
    match person with
    | Some(p) -> printfn "%A" p
    | None -> printfn "No person given" 

let NullExample() = 
    PrintPerson None

let RealExample() =
    PrintPerson (Some({Name="Bob"; Age=52;}))
					</code></pre>
					<div class="fragment">
						Pretty printing built in
						<pre class="fragment"><code class="hljs nohighlight" data-trim>								
{Name = "Bob";
Age = 52;}
						</code></pre>
					</div>
				</section>




				<section>
					<h2>Union types</h2>
					<pre><code class="fsharp hljs" data-trim>	
namespace FSharp

open System

module Parser = 
    let TryParseInt value = 
        try
            Some(Int32.Parse value)
        with
        | _ -> None

    let ReadInt() = 
        let line = Console.ReadLine()
        match TryParseInt line with
        | Some(i) -> printfn "Successfully read integer: %i" i
        | None -> printfn "Failed to read integer"
					</code></pre>
				</section>





				<section>					
					<pre class="smallCode"><code class="hljs" data-trim>	
using System;

namespace CSharp
{
    public class Parser
    {
        public static bool TryParseInt(string value, out int i)
        {
            i = 0;

            try
            {
                i = int.Parse(value);
                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        public static void ReadInt()
        {
            var line = Console.ReadLine();
            int i;
            if (TryParseInt(line, out i))
            {
                Console.WriteLine($"Successfully read integer: {i}");
            }
            else
            {
                Console.WriteLine("Failed to read integer");
            }
        }
    }
}
					</code></pre>						
				</section>



				<section>
					<h2>Union types</h2>
					<div class="fragment">
						<pre><code class="fsharp hljs" data-trim>	
type Shape =
| Line of int
| Square of int:width * int:height
| Triangle of int * int * int
| Cube of int * int * int
						</code></pre>						
					</div>					
					<div class="fragment">
						<pre><code class="fsharp hljs" data-trim>	
let line = Line(5)
let square = Square(2,7)
						</code></pre>
					</div>
					<div class="fragment">
						<pre><code class="fsharp hljs" data-trim>	
let PrintShape shape = 
    match shape with
    | Line(length) -> 
        sprintf "This is a line of length %i" length
    | Square(width, height) -> 
        sprintf "This is a square of dimensions %i,%i" width height
						</code></pre>							
					</div>
					<div class="fragment">
						<pre><code class="fsharp hljs" data-trim>	
Incomplete pattern matches on this expression. 
For example, the value 'Cube (_, _, _)' 
may indicate a case not covered by the pattern(s).					
						</code></pre>
					</div>
				</section>




				<section>
					<h2>Units of measure</h2>
					<pre><code class="fsharp hljs" data-trim>
[&ltMeasure&gt] type USD
[&ltMeasure&gt] type GBP					
					</code></pre>
					<pre class="fragment"><code class="fsharp hljs" data-trim>					
let AddAmounts (x:int&ltUSD&gt) (y:int&ltUSD&gt) = 
    x + y
					</code></pre>
					<pre class="fragment"><code class="fsharp hljs" data-trim>					
let TestAdder() = 
    AddAmounts 1&ltUSD&gt 2&ltUSD&gt
    				</code></pre>
    				<pre class="fragment"><code class="fsharp hljs" data-trim>					
let TestAdderInvalid() = 
    AddAmounts 1&ltUSD&gt 2
					</code></pre>
					<pre class="fragment">
This expression was expected to have type
<br/>int&ltUSD&gt
<br/>but here has type
int</pre>
				</section>





				<section>
					<pre><code class="fsharp hljs" data-trim>					
let TestAdderInvalid2() = 
    AddAmounts 1&ltUSD&gt 2&ltGBP&gt
					</code></pre>
					<pre class="fragment">
Type mismatch. Expecting a
<br/>int&ltUSD&gt
<br/>but given a
<br/>int&ltGBP&gt
<br/>The unit of measure 'USD' does not match the unit of measure 'GBP'</pre>
					<pre class="fragment"><code class="fsharp hljs" data-trim>					
let AddAmounts (x:int&lt'a&gt) (y:int&lt'a&gt) = 
    x + y
					</code></pre>
				</section>



				



				<section>
					<h2>Type Providers</h2>
					Infer the structure of a sample document and provide type-safe access
					<pre class="fragment"><code class="fsharp hljs" data-trim>	
open FSharp.Data

// Infer type from sample JSON
type Person = JsonProvider<""" { "name":"John", "age":94} """>

// Parse real input
let thomas = Person.Parse """ { "name":"Thomas", "age":14 } """
printfn "%s" thomas.Name
printfn "%i" thomas.Age      
					</code></pre>
				</section>





				<section>
					<pre><code class="fsharp hljs" data-trim>	
open FSharp.Data

type EntitlementUser = JsonProvider<""" [{"aqrUserId":"wallisd","userName":"Daniel Wallis","altName":"Daniel Wallis","department":"IT","group":"Enterprise Dev","hR_Id":56368,"aqrTitle":"Analyst","isManager":false,"manager":"Vitaliy Razhanskiy","managerId":"razhanskiyv","hireDate":"2016-04-11T00:00:00","employeeType":"Employee","adpGroupNumber":"71","email":"Daniel.Wallis@aqr.com","degree":null,"firstName":"Daniel","lastName":"Wallis"}] """>    

let PrintAllUsers() = 
    let url = "http://aqrweb/entitlementsystem/api/entitlement/GetHRUsers"    
    let rawJson = Http.RequestString(url, customizeHttpRequest = fun req -> req.UseDefaultCredentials <- true
                                                                            req)    
    EntitlementUser.Parse rawJson
    |> Seq.iter (fun user -> printfn "%s - %s" user.AqrUserId user.AltName)    					
					</code></pre>
					<div class="fragment">
					Type providers also exist for CSV, HTML, XML and WorldBank
					</div>
				</section>





				<section>
				<h2>One last thing...</h2>
				<div style="float:left;width:50%;">
					<pre style="font-size: 0.05em"><code class="fsharp hljs" data-trim>
namespace Mastermind

open System

type Result&lt'a,'b&gt = 
    |ValidGuess of 'a
    |InvalidGuess of 'b

type MatchResult = 
    |Correct
    |InWrongPlace
    |Incorrect

module CodeComparer =    
    let updateMatchedItems i = 
        Seq.mapi (fun idx existingItem -&gt if idx = i then true else existingItem)

    let findItemInWrongPlace item matchedItems = 
        Seq.mapi (fun cidx citem -&gt cidx, citem)
        &gt&gt Seq.filter (fun (cidx, citem) -&gt (not &lt| Seq.item cidx matchedItems) && citem = item)
        &gt&gt Seq.map fst
        &gt&gt Seq.tryHead

    let compareOne code acc pair = 
        let existingResults, matchedItems = acc
        let i, item = pair
        let result, newMatchedItems = 
                    if item = Seq.item i code then
                        Correct, (matchedItems |&gt updateMatchedItems i)
                    else
                        match code |&gt findItemInWrongPlace item matchedItems with
                        |Some(matchedI) -&gt InWrongPlace, (matchedItems |&gt updateMatchedItems matchedI)
                        |None -&gt Incorrect, matchedItems                     
        
        (List.append existingResults [result]), newMatchedItems

    let getAllInCorrectPlace guess code = 
        guess |&gt Seq.mapi (fun idx item -&gt Seq.item idx code = item)

    let compare guess code = 
        let codeLength = Seq.length code
        if Seq.length guess &lt&gt codeLength then
            InvalidGuess(sprintf "Incorrect guess length. Expected length: %i" codeLength)
        else
            let matchedItems = getAllInCorrectPlace guess code
            guess 
            |&gt Seq.mapi (fun i item -&gt i, item)
            |&gt Seq.fold (compareOne code) ([], matchedItems)
            |&gt fst
            |&gt ValidGuess

    let compareAndPrintResult guess code = 
        match compare guess code with
        |ValidGuess(result) -&gt printfn "%A , %A = %A" guess code result
        |InvalidGuess(f) -&gt printfn "%A , %A = %s" guess code f

module Game = 
    let compareResults result1 result2 = 
        match result1 with
        | ValidGuess(m) -&gt
            let length = m |&gt Seq.length
            [0..length-1]
            |&gt Seq.forall (fun i -&gt Seq.item i m = Seq.item i result2)
        | InvalidGuess(e) -&gt false

    let rec start code remainingGuesses = 
        let guess = remainingGuesses |&gt Seq.head
        let result = CodeComparer.compare guess code
        match result with
        | ValidGuess(m) -&gt 
            if m |&gt Seq.forall (fun r -&gt match r with 
                                         |Correct -&gt true
                                         | _ -&gt false) then
                guess
            else
                remainingGuesses
                |&gt Seq.skip 1
                |&gt Seq.filter (fun g -&gt let r = (CodeComparer.compare g guess)
                                        compareResults r m)
                |&gt start code
        | InvalidGuess(e) -&gt invalidOp e

    let rec generateGuesses length (options:list&lt'a&gt) (existingGuesses:list&ltlist&lt'a&gt&gt) = 
        if length = 0 then
            existingGuesses
        else
            options
            |&gt List.collect (fun o -&gt if Seq.isEmpty existingGuesses then
                                          [[o]]
                                      else
                                          existingGuesses |&gt List.map (fun g -&gt List.append [o] g))
            |&gt generateGuesses (length-1) options

    let playGame() = 
        let options = [1..6]        
        let length = 4
        let random = new Random()
        let code = [1..length] |&gt List.map (fun i -&gt Seq.item (random.Next(Seq.length options)) options)        
        printfn "%A" code
        let allGuesses = generateGuesses length options []
        printfn "%A" allGuesses
        start code allGuesses        
					</code></pre>
					</div>
					<div style="float:right;width:50%;">
					<pre style="font-size: 0.05em"><code class="hljs" data-trim>
using System;
using System.Collections.Generic;
using System.Linq;

namespace MastermindCSharp
{
    internal class Some&ltT&gt : Option&ltT&gt
    {
        private readonly T value;

        public Some(T value)
        {
            this.value = value;
        }

        public T Value =&gt value;

        public override TResult AcceptVisitor&ltTResult&gt(Func&ltSome&ltT&gt, TResult&gt someVisitor, Func&ltNone&ltT&gt, TResult&gt noneVisitor)
        {
            return someVisitor(this);
        }
    }

    internal class None&ltT&gt : Option&ltT&gt
    {
        public override TResult AcceptVisitor&ltTResult&gt(Func&ltSome&ltT&gt, TResult&gt someVisitor, Func&ltNone&ltT&gt, TResult&gt noneVisitor)
        {
            return noneVisitor(this);
        }
    }

    internal abstract class Option&ltT&gt
    {
        public abstract TResult AcceptVisitor&ltTResult&gt(Func&ltSome&ltT&gt, TResult&gt someVisitor, Func&ltNone&ltT&gt, TResult&gt noneVisitor);
    }

    internal abstract class Result&ltTSuccess, TFailure&gt
    {
        public abstract TResult AcceptVisitor&ltTResult&gt(Func&ltTSuccess, TResult&gt successVisitor, Func&ltTFailure, TResult&gt failureVisitor);
    }

    internal class ValidGuess : Result&ltValidGuess, InvalidGuess&gt
    {
        private readonly List&ltMatchResult&gt result;

        public ValidGuess(List&ltMatchResult&gt result)
        {
            this.result = result;
        }

        public List&ltMatchResult&gt Result =&gt result;

        public override TResult AcceptVisitor&ltTResult&gt(Func&ltValidGuess, TResult&gt successVisitor, Func&ltInvalidGuess, TResult&gt failureVisitor)
        {
            return successVisitor(this);
        }
    }

    internal class InvalidGuess : Result&ltValidGuess, InvalidGuess&gt
    {
        private readonly string message;

        public InvalidGuess(string message)
        {
            this.message = message;
        }

        public string Message =&gt message;

        public override TResult AcceptVisitor&ltTResult&gt(Func&ltValidGuess, TResult&gt successVisitor, Func&ltInvalidGuess, TResult&gt failureVisitor)
        {
            return failureVisitor(this);
        }
    }

    internal enum MatchResult
    {
        Correct,
        InWrongPlace,
        Incorrect
    }

    public class CodeComparer
    {
        internal static IEnumerable&ltbool&gt UpdateMatchedItems(int i, IEnumerable&ltbool&gt existingItems)
        {
            return existingItems.Select((existingItem, idx) =&gt idx == i || existingItem);
        }

        private static Option&ltint&gt FindItemInWrongPlace&ltT&gt(T item, IEnumerable&ltbool&gt matchedItems, IEnumerable&ltT&gt items)
        {
            var result = items
                .Select((citem, cindex) =&gt Tuple.Create(cindex, citem))
                .Where(tuple =&gt !matchedItems.ElementAt(tuple.Item1) && Equals(tuple.Item2, item))
                .Select(tuple =&gt tuple.Item1);
            return result.Any() ? (Option&ltint&gt)new Some&ltint&gt(result.First()) : new None&ltint&gt();
        }

        private static Tuple&ltList&ltMatchResult&gt, IEnumerable&ltbool&gt&gt CompareOne&ltT&gt(IEnumerable&ltT&gt code, Tuple&ltList&ltMatchResult&gt, IEnumerable&ltbool&gt&gt acc, Tuple&ltint, T&gt pair)
        {
            var existingResults = acc.Item1;
            var matchedItems = acc.Item2;
            var i = pair.Item1;
            var item = pair.Item2;
            var tuple = Equals(item, code.ElementAt(i))
                ? Tuple.Create(MatchResult.Correct, UpdateMatchedItems(i, matchedItems))
                : FindItemInWrongPlace(item, matchedItems, code)
                    .AcceptVisitor(
                    some =&gt Tuple.Create(MatchResult.InWrongPlace, UpdateMatchedItems(some.Value, matchedItems)),
                    none =&gt Tuple.Create(MatchResult.Incorrect, matchedItems));

            return Tuple.Create(existingResults.Concat(new List&ltMatchResult&gt {tuple.Item1}).ToList(), tuple.Item2);
        }

        private static IEnumerable&ltbool&gt GetAllInCorrectPlace&ltT&gt(IEnumerable&ltT&gt guess, IEnumerable&ltT&gt code)
        {
            return guess.Select((item, idx) =&gt Equals(code.ElementAt(idx), item));
        }

        internal static Result&ltValidGuess, InvalidGuess&gt Compare&ltT&gt(IEnumerable&ltT&gt guess, IEnumerable&ltT&gt code)
        {
            var codeLength = code.Count();
            if (guess.Count() != codeLength)
            {
                return new InvalidGuess($"Incorrect guess length. Expected length: {codeLength}");
            }

            var matchedItems = GetAllInCorrectPlace(guess, code);
            return new ValidGuess(guess
                .Select((item, i) =&gt Tuple.Create(i, item))
                .Aggregate(Tuple.Create(new List&ltMatchResult&gt(), matchedItems),
                    (acc, pair) =&gt CompareOne(code, acc, pair))
                .Item1);
        }

        private void CompareAndPrintResult&ltT&gt(IEnumerable&ltT&gt guess, IEnumerable&ltT&gt code)
        {
            var result = Compare(guess, code);
            result.AcceptVisitor&ltobject&gt(
                validGuess =&gt
                {
                    Console.WriteLine(
                        $"{Utils.ConvertIEnumerableToString(guess)}, {Utils.ConvertIEnumerableToString(code)}, {Utils.ConvertIEnumerableToString(validGuess.Result)}");
                    return null;
                },
                invalidGuess =&gt
                {
                    Console.WriteLine(
                        $"{Utils.ConvertIEnumerableToString(guess)}, {Utils.ConvertIEnumerableToString(code)}, {Utils.ConvertIEnumerableToString(invalidGuess.Message)}");
                    return null;
                });
        }
    }

    internal class Game
    {
        internal static bool CompareResults&ltT&gt(IEnumerable&ltT&gt result2, Result&ltValidGuess, InvalidGuess&gt result1)
        {
            return result1.AcceptVisitor(
                validGuess =&gt {
                    var m = validGuess.Result;
                    var length = m.Count;
                    return Enumerable.Range(0, length).All(i =&gt Equals(m.ElementAt(i), result2.ElementAt(i)));
                },
                invalidGuess =&gt false);
        }

        internal static IEnumerable&ltT&gt Start&ltT&gt(IEnumerable&ltT&gt code, IEnumerable&ltIEnumerable&ltT&gt&gt remainingGuesses)
        {
            var guess = remainingGuesses.First();
            Console.WriteLine($"Guess: {Utils.ConvertIEnumerableToString(guess)}");
            var result = CodeComparer.Compare(guess, code);
            return result.AcceptVisitor(
                validGuess =&gt {
                    var m = validGuess.Result;
                    return m.All(r =&gt r == MatchResult.Correct)
                        ? guess
                        : Start(code, remainingGuesses
                            .Skip(1)
                            .Where(g =&gt
                            {
                                var r = CodeComparer.Compare(g, guess);
                                return CompareResults(m, r);
                            }));
                },
                invalidGuess =&gt { throw new InvalidOperationException(invalidGuess.Message); });
        }

        private static List&ltList&ltT&gt&gt GenerateGuesses&ltT&gt(int length, IEnumerable&ltT&gt options, List&ltList&ltT&gt&gt existingGuesses)
        {
            return length == 0
                ? existingGuesses
                : GenerateGuesses(length - 1, options, options
                    .SelectMany(o =&gt
                    {
                        return !existingGuesses.Any()
                            ? new List&ltList&ltT&gt&gt {new List&ltT&gt {o}}
                            : existingGuesses.Select(g =&gt new List&ltT&gt {o}.Concat(g).ToList());
                    }).ToList());
        }

        internal static void PlayGame()
        {
            var options = Enumerable.Range(1, 6).ToList();
            const int length = 4;
            var random = new Random();
            var code = Enumerable.Range(1, length).Select(i =&gt options.ElementAt(random.Next(options.Count))).ToList();
            Console.WriteLine(Utils.ConvertIEnumerableToString(code));
            var allGuesses = GenerateGuesses(length, options, new List&ltList&ltint&gt&gt());
            Console.WriteLine(Utils.ConvertIEnumerableOfIEnumerablesToString(allGuesses));
            Start(code, allGuesses);
        }
    }

    internal class Utils
    {
        internal static string ConvertIEnumerableToString&ltT&gt(IEnumerable&ltT&gt code)
        {
            return $"[{string.Join(",", code)}]";
        }

        internal static string ConvertIEnumerableOfIEnumerablesToString&ltT&gt(IEnumerable&ltIEnumerable&ltT&gt&gt allGuesses)
        {
            return string.Join("\n", allGuesses.Select(ConvertIEnumerableToString));
        }
    }
}
					</code></pre>
					</div>
				</section>






				<section>
					<h1>Useful links</h1>
					<ul>
					<li><a href="https://fsharpforfunandprofit.com/">F# for fun and profit</a></li>
					<li><a href="http://fsharp.github.io/FSharp.Data/">F# Data</a></li>
					<li><a href="https://blogs.msdn.microsoft.com/dotnet/2016/12/13/project-springfield-a-cloud-service-built-entirely-in-f/">Project Springfield</a></li>
					</ul>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				//height:"100%",
				//width:"75%",				
				height:"1080",
				width:"1920",				
				history: true,
				zoomKey: "ctrl",

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
